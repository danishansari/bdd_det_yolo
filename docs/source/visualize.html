<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>source.visualize API documentation</title>
<meta name="description" content="This file is to provide visualization functionalities for Yolo models â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>source.visualize</code></h1>
</header>
<section id="section-intro">
<p>This file is to provide visualization functionalities for Yolo models</p>
<p>author: danish ansari
copyright: na</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This file is to provide visualization functionalities for Yolo models

author: danish ansari
copyright: na
&#34;&#34;&#34;

from data_loader import BDDLoader
from matplotlib import pyplot as plt
from matplotlib.pyplot import cm
import seaborn as sn
import os
from PIL import ImageDraw, ImageFont, ImageColor
import numpy as np
import pandas as pd


class Visualize:
    &#34;&#34;&#34;
    Class to visulalize dataset distribution and attributes
    - plots train/val sample distribution
    - plots class wise sample distribution
    - plots size vs no of samples in training data
    - show yolo annotations plotted on images
    &#34;&#34;&#34;

    def __init__(self, path: str) -&gt; None:
        self.trn_loader = BDDLoader(path, &#34;train&#34;)
        self.val_loader = BDDLoader(path, &#34;val&#34;)
        self.train_val_data = {
            &#34;train&#34;: {&#34;class&#34;: {}},
            &#34;val&#34;: {&#34;class&#34;: {}},
        }
        self.load_data()
        os.makedirs(&#34;plots&#34;, exist_ok=True)

    def load_data(self):
        &#34;&#34;&#34;Function to load train and eval data classwise in memory from dataloader
        to perform analysis.
        &#34;&#34;&#34;
        for im, lab, atr in self.trn_loader:
            b = self.trn_loader.scale_box(lab)
            for i, (c, b) in enumerate(lab):
                cat = self.trn_loader.data.config[&#34;names&#34;][c]
                if cat in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
                    self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][0] += 1
                    self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][1].append(b[2])
                    self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][2].append(b[3])
                    self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][3].append(atr[i])
                else:
                    self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat] = [
                        1,
                        [b[2]],
                        [b[3]],
                        [atr[i]],
                    ]

        for im, lab, atr in self.val_loader:
            b = self.trn_loader.scale_box(lab)
            for i, (c, b) in enumerate(lab):
                cat = self.trn_loader.data.config[&#34;names&#34;][c]
                if cat in self.train_val_data[&#34;val&#34;][&#34;class&#34;]:
                    self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][0] += 1
                    self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][1].append(b[2])
                    self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][2].append(b[3])
                    self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][2].append(atr[i])
                else:
                    self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat] = [
                        1,
                        [b[2]],
                        [b[3]],
                        [atr[i]],
                    ]

    def train_val_distribution(self):
        &#34;&#34;&#34;Function to plot tain-val data distribution&#34;&#34;&#34;
        data = [&#34;train&#34;, &#34;val&#34;]
        samples = [len(self.trn_loader), len(self.val_loader)]

        plt.figure(figsize=(8, 6))
        plt.bar(data, samples, color=&#34;blue&#34;, width=0.4)
        plt.ylabel(&#34;Number of samples&#34;)
        plt.title(&#34;BDD dataset training data distribution&#34;)
        plt.savefig(&#34;plots/train_val_dist.png&#34;)

    def class_wise_data_distribution(self):
        &#34;&#34;&#34;Function to plot class wise data distribution&#34;&#34;&#34;
        data = self.train_val_data[&#34;train&#34;][&#34;class&#34;].keys()
        train_count = [x[0] for x in self.train_val_data[&#34;train&#34;][&#34;class&#34;].values()]
        X_axis = np.arange(len(data))
        plt.figure(figsize=(8, 6))
        plt.xticks(X_axis, data)
        plt.xticks(rotation=45, ha=&#34;right&#34;)
        plt.bar(data, train_count, 0.4, color=&#34;blue&#34;)
        plt.xlabel(&#34;class&#34;)
        plt.ylabel(&#34;Number of samples&#34;)
        plt.title(&#34;BDD dataset training class distribution&#34;)
        plt.savefig(&#34;plots/training_class_dist.png&#34;)
        data = self.train_val_data[&#34;val&#34;][&#34;class&#34;].keys()
        val_count = [x[0] for x in self.train_val_data[&#34;val&#34;][&#34;class&#34;].values()]
        X_axis = np.arange(len(data))
        plt.figure(figsize=(8, 6))
        plt.xticks(X_axis, data)
        plt.xticks(rotation=45, ha=&#34;right&#34;)
        plt.bar(data, val_count, 0.4, color=&#34;orange&#34;)
        plt.xlabel(&#34;class&#34;)
        plt.ylabel(&#34;Number of samples&#34;)
        plt.title(&#34;BDD dataset training class distribution&#34;)
        plt.savefig(&#34;plots/eval_class_dist.png&#34;)

    def object_size_distribution(self):
        &#34;&#34;&#34;Function to plot width/heigh confusion metrix&#34;&#34;&#34;
        array = [[0 for i in range(13)] for j in range(8)]
        tot = 0
        for c in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
            for i in range(len(self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1])):
                w = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1][i] // 100
                h = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][2][i] // 100
                tot += 1
                array[h][w] = array[h][w] + (1 / tot)

        df_cm = pd.DataFrame(
            array,
            index=[i * 100 for i in range(8)],
            columns=[i * 100 for i in range(13)],
        )
        plt.figure(figsize=(10, 7))
        sn.heatmap(df_cm, annot=True, fmt=&#34;.1f&#34;)
        plt.savefig(&#34;plots/training_size_dist.png&#34;)

    def class_size_distribution(self):
        &#34;&#34;&#34;Function to plot object-size(area) vs no of sample distribution&#34;&#34;&#34;
        class_area_avg = {}
        tot_area = 0
        tot_sample = 0
        for c in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
            for i in range(len(self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1])):
                w = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1][i] // 100
                h = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][2][i] // 100
                tot_area += w * h
                tot_sample += 1
                if c in class_area_avg:
                    class_area_avg[c][0] += w * h
                    class_area_avg[c][1] += 1
                else:
                    class_area_avg[c] = [(w * h), 1]
        color = cm.rainbow(np.linspace(0, 1, 10))
        fig, ax = plt.subplots()
        for i, c in enumerate(class_area_avg.keys()):
            circle = plt.Circle(
                ((i + 1) / 10, (class_area_avg[c][1] / tot_sample)),
                class_area_avg[c][0] / (tot_area * 2),
                color=color[i],
            )
            ax.annotate(
                c, xy=((i + 1) / 10, (class_area_avg[c][1] / tot_sample)), fontsize=12
            )
            ax.add_patch(circle)
        plt.ylabel(&#34;Number of samples&#34;)
        plt.title(&#34;Object-size vs #samples distribution&#34;)
        plt.savefig(&#34;plots/object_size_dist.png&#34;)

    def data_attributes_distribution(self):
        &#34;&#34;&#34;Function to plot data occlusion and trucation distribution&#34;&#34;&#34;
        attrib_counts = {&#34;occuluded&#34;: [0, 0], &#34;truncated&#34;: [0, 0]}
        for c in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
            for i in range(len(self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][3])):
                atr = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][3][i]
                attrib_counts[&#34;occuluded&#34;][1] += 1
                attrib_counts[&#34;truncated&#34;][1] += 1
                if atr[1]:
                    attrib_counts[&#34;occuluded&#34;][0] += 1
                if atr[2]:
                    attrib_counts[&#34;truncated&#34;][0] += 1

        fig, ax = plt.subplots()
        bottom = np.zeros(2)
        for cls, count in attrib_counts.items():
            p = ax.bar([&#34;occuluded&#34;, &#34;truncated&#34;], count, 0.5, label=cls, bottom=bottom)
            bottom += count
        plt.savefig(&#34;plots/object_attr_dist.png&#34;)

    def train_size_vs_map(self):
        &#34;&#34;&#34;Function to plot train/val size vs map&#34;&#34;&#34;
        data = self.train_val_data[&#34;train&#34;][&#34;class&#34;].keys()
        train_count = [x[0] for x in self.train_val_data[&#34;train&#34;][&#34;class&#34;].values()]
        tot = sum(train_count)
        for i in range(len(train_count)):
            train_count[i] /= tot
        val_count = [0.57, 0.62, 0.77, 0.59, 0.43, 0.43, 0.62, 0.60, 0.42, 0.0]
        X_axis = np.arange(len(data))
        plt.figure(figsize=(8, 6))
        plt.xticks(X_axis, data)
        plt.xticks(rotation=45, ha=&#34;right&#34;)
        plt.bar(X_axis - 0.2, train_count, 0.4, label=&#34;samples&#34;)
        plt.bar(X_axis + 0.2, val_count, 0.4, label=&#34;mAP&#34;)
        plt.legend()
        plt.xlabel(&#34;class&#34;)
        plt.ylabel(&#34;Number of samples&#34;)
        plt.title(&#34;BDD dataset samples vs map distribution&#34;)
        plt.savefig(&#34;plots/sample_map_dist.png&#34;)

    def show_yolo_annotations(self) -&gt; None:
        &#34;&#34;&#34;Function to overlay annotations on images&#34;&#34;&#34;
        os.makedirs(&#34;plots/images&#34;, exist_ok=True)
        colors = list(ImageColor.colormap.keys())[:10]
        font = ImageFont.truetype(&#34;plots/font/Arial.ttf&#34;, 24)
        for img, lab, atr in self.val_loader:
            draw = ImageDraw.Draw(img)
            lab = self.val_loader.scale_box(lab)
            for ann in lab:
                c, b = ann
                cls = self.val_loader.data.config[&#34;names&#34;][c]
                draw.rectangle(b, fill=None, outline=colors[c], width=3)
                draw.text((b[0] + 5, b[1]), cls[:3], font=font, fill=&#34;red&#34;)
            draw.text((5, 5), f&#34;* {atr[0][3]}&#34;, align=&#34;left&#34;, font=font, fill=&#34;red&#34;)
            draw.text((5, 25), f&#34;* {atr[0][4]}&#34;, align=&#34;left&#34;, font=font, fill=&#34;red&#34;)
            draw.text((5, 45), f&#34;* {atr[0][5]}&#34;, align=&#34;left&#34;, font=font, fill=&#34;red&#34;)
            img.save(&#34;plots/images/tmp.jpg&#34;)
            if input(&#34;&gt; &#34;) == &#34;s&#34;:
                img.save(f&#34;plots/images/{os.path.basename(self.val_loader.curr_fname)}&#34;)

    def all(self):
        &#34;&#34;&#34;Function to make all plots for data vizualization&#34;&#34;&#34;
        self.train_val_distribution()
        self.class_wise_data_distribution()
        self.object_size_distribution()
        self.class_size_distribution()
        self.data_attributes_distribution()
        self.train_size_vs_map()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="source.visualize.Visualize"><code class="flex name class">
<span>class <span class="ident">Visualize</span></span>
<span>(</span><span>path:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to visulalize dataset distribution and attributes
- plots train/val sample distribution
- plots class wise sample distribution
- plots size vs no of samples in training data
- show yolo annotations plotted on images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Visualize:
    &#34;&#34;&#34;
    Class to visulalize dataset distribution and attributes
    - plots train/val sample distribution
    - plots class wise sample distribution
    - plots size vs no of samples in training data
    - show yolo annotations plotted on images
    &#34;&#34;&#34;

    def __init__(self, path: str) -&gt; None:
        self.trn_loader = BDDLoader(path, &#34;train&#34;)
        self.val_loader = BDDLoader(path, &#34;val&#34;)
        self.train_val_data = {
            &#34;train&#34;: {&#34;class&#34;: {}},
            &#34;val&#34;: {&#34;class&#34;: {}},
        }
        self.load_data()
        os.makedirs(&#34;plots&#34;, exist_ok=True)

    def load_data(self):
        &#34;&#34;&#34;Function to load train and eval data classwise in memory from dataloader
        to perform analysis.
        &#34;&#34;&#34;
        for im, lab, atr in self.trn_loader:
            b = self.trn_loader.scale_box(lab)
            for i, (c, b) in enumerate(lab):
                cat = self.trn_loader.data.config[&#34;names&#34;][c]
                if cat in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
                    self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][0] += 1
                    self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][1].append(b[2])
                    self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][2].append(b[3])
                    self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][3].append(atr[i])
                else:
                    self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat] = [
                        1,
                        [b[2]],
                        [b[3]],
                        [atr[i]],
                    ]

        for im, lab, atr in self.val_loader:
            b = self.trn_loader.scale_box(lab)
            for i, (c, b) in enumerate(lab):
                cat = self.trn_loader.data.config[&#34;names&#34;][c]
                if cat in self.train_val_data[&#34;val&#34;][&#34;class&#34;]:
                    self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][0] += 1
                    self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][1].append(b[2])
                    self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][2].append(b[3])
                    self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][2].append(atr[i])
                else:
                    self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat] = [
                        1,
                        [b[2]],
                        [b[3]],
                        [atr[i]],
                    ]

    def train_val_distribution(self):
        &#34;&#34;&#34;Function to plot tain-val data distribution&#34;&#34;&#34;
        data = [&#34;train&#34;, &#34;val&#34;]
        samples = [len(self.trn_loader), len(self.val_loader)]

        plt.figure(figsize=(8, 6))
        plt.bar(data, samples, color=&#34;blue&#34;, width=0.4)
        plt.ylabel(&#34;Number of samples&#34;)
        plt.title(&#34;BDD dataset training data distribution&#34;)
        plt.savefig(&#34;plots/train_val_dist.png&#34;)

    def class_wise_data_distribution(self):
        &#34;&#34;&#34;Function to plot class wise data distribution&#34;&#34;&#34;
        data = self.train_val_data[&#34;train&#34;][&#34;class&#34;].keys()
        train_count = [x[0] for x in self.train_val_data[&#34;train&#34;][&#34;class&#34;].values()]
        X_axis = np.arange(len(data))
        plt.figure(figsize=(8, 6))
        plt.xticks(X_axis, data)
        plt.xticks(rotation=45, ha=&#34;right&#34;)
        plt.bar(data, train_count, 0.4, color=&#34;blue&#34;)
        plt.xlabel(&#34;class&#34;)
        plt.ylabel(&#34;Number of samples&#34;)
        plt.title(&#34;BDD dataset training class distribution&#34;)
        plt.savefig(&#34;plots/training_class_dist.png&#34;)
        data = self.train_val_data[&#34;val&#34;][&#34;class&#34;].keys()
        val_count = [x[0] for x in self.train_val_data[&#34;val&#34;][&#34;class&#34;].values()]
        X_axis = np.arange(len(data))
        plt.figure(figsize=(8, 6))
        plt.xticks(X_axis, data)
        plt.xticks(rotation=45, ha=&#34;right&#34;)
        plt.bar(data, val_count, 0.4, color=&#34;orange&#34;)
        plt.xlabel(&#34;class&#34;)
        plt.ylabel(&#34;Number of samples&#34;)
        plt.title(&#34;BDD dataset training class distribution&#34;)
        plt.savefig(&#34;plots/eval_class_dist.png&#34;)

    def object_size_distribution(self):
        &#34;&#34;&#34;Function to plot width/heigh confusion metrix&#34;&#34;&#34;
        array = [[0 for i in range(13)] for j in range(8)]
        tot = 0
        for c in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
            for i in range(len(self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1])):
                w = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1][i] // 100
                h = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][2][i] // 100
                tot += 1
                array[h][w] = array[h][w] + (1 / tot)

        df_cm = pd.DataFrame(
            array,
            index=[i * 100 for i in range(8)],
            columns=[i * 100 for i in range(13)],
        )
        plt.figure(figsize=(10, 7))
        sn.heatmap(df_cm, annot=True, fmt=&#34;.1f&#34;)
        plt.savefig(&#34;plots/training_size_dist.png&#34;)

    def class_size_distribution(self):
        &#34;&#34;&#34;Function to plot object-size(area) vs no of sample distribution&#34;&#34;&#34;
        class_area_avg = {}
        tot_area = 0
        tot_sample = 0
        for c in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
            for i in range(len(self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1])):
                w = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1][i] // 100
                h = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][2][i] // 100
                tot_area += w * h
                tot_sample += 1
                if c in class_area_avg:
                    class_area_avg[c][0] += w * h
                    class_area_avg[c][1] += 1
                else:
                    class_area_avg[c] = [(w * h), 1]
        color = cm.rainbow(np.linspace(0, 1, 10))
        fig, ax = plt.subplots()
        for i, c in enumerate(class_area_avg.keys()):
            circle = plt.Circle(
                ((i + 1) / 10, (class_area_avg[c][1] / tot_sample)),
                class_area_avg[c][0] / (tot_area * 2),
                color=color[i],
            )
            ax.annotate(
                c, xy=((i + 1) / 10, (class_area_avg[c][1] / tot_sample)), fontsize=12
            )
            ax.add_patch(circle)
        plt.ylabel(&#34;Number of samples&#34;)
        plt.title(&#34;Object-size vs #samples distribution&#34;)
        plt.savefig(&#34;plots/object_size_dist.png&#34;)

    def data_attributes_distribution(self):
        &#34;&#34;&#34;Function to plot data occlusion and trucation distribution&#34;&#34;&#34;
        attrib_counts = {&#34;occuluded&#34;: [0, 0], &#34;truncated&#34;: [0, 0]}
        for c in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
            for i in range(len(self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][3])):
                atr = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][3][i]
                attrib_counts[&#34;occuluded&#34;][1] += 1
                attrib_counts[&#34;truncated&#34;][1] += 1
                if atr[1]:
                    attrib_counts[&#34;occuluded&#34;][0] += 1
                if atr[2]:
                    attrib_counts[&#34;truncated&#34;][0] += 1

        fig, ax = plt.subplots()
        bottom = np.zeros(2)
        for cls, count in attrib_counts.items():
            p = ax.bar([&#34;occuluded&#34;, &#34;truncated&#34;], count, 0.5, label=cls, bottom=bottom)
            bottom += count
        plt.savefig(&#34;plots/object_attr_dist.png&#34;)

    def train_size_vs_map(self):
        &#34;&#34;&#34;Function to plot train/val size vs map&#34;&#34;&#34;
        data = self.train_val_data[&#34;train&#34;][&#34;class&#34;].keys()
        train_count = [x[0] for x in self.train_val_data[&#34;train&#34;][&#34;class&#34;].values()]
        tot = sum(train_count)
        for i in range(len(train_count)):
            train_count[i] /= tot
        val_count = [0.57, 0.62, 0.77, 0.59, 0.43, 0.43, 0.62, 0.60, 0.42, 0.0]
        X_axis = np.arange(len(data))
        plt.figure(figsize=(8, 6))
        plt.xticks(X_axis, data)
        plt.xticks(rotation=45, ha=&#34;right&#34;)
        plt.bar(X_axis - 0.2, train_count, 0.4, label=&#34;samples&#34;)
        plt.bar(X_axis + 0.2, val_count, 0.4, label=&#34;mAP&#34;)
        plt.legend()
        plt.xlabel(&#34;class&#34;)
        plt.ylabel(&#34;Number of samples&#34;)
        plt.title(&#34;BDD dataset samples vs map distribution&#34;)
        plt.savefig(&#34;plots/sample_map_dist.png&#34;)

    def show_yolo_annotations(self) -&gt; None:
        &#34;&#34;&#34;Function to overlay annotations on images&#34;&#34;&#34;
        os.makedirs(&#34;plots/images&#34;, exist_ok=True)
        colors = list(ImageColor.colormap.keys())[:10]
        font = ImageFont.truetype(&#34;plots/font/Arial.ttf&#34;, 24)
        for img, lab, atr in self.val_loader:
            draw = ImageDraw.Draw(img)
            lab = self.val_loader.scale_box(lab)
            for ann in lab:
                c, b = ann
                cls = self.val_loader.data.config[&#34;names&#34;][c]
                draw.rectangle(b, fill=None, outline=colors[c], width=3)
                draw.text((b[0] + 5, b[1]), cls[:3], font=font, fill=&#34;red&#34;)
            draw.text((5, 5), f&#34;* {atr[0][3]}&#34;, align=&#34;left&#34;, font=font, fill=&#34;red&#34;)
            draw.text((5, 25), f&#34;* {atr[0][4]}&#34;, align=&#34;left&#34;, font=font, fill=&#34;red&#34;)
            draw.text((5, 45), f&#34;* {atr[0][5]}&#34;, align=&#34;left&#34;, font=font, fill=&#34;red&#34;)
            img.save(&#34;plots/images/tmp.jpg&#34;)
            if input(&#34;&gt; &#34;) == &#34;s&#34;:
                img.save(f&#34;plots/images/{os.path.basename(self.val_loader.curr_fname)}&#34;)

    def all(self):
        &#34;&#34;&#34;Function to make all plots for data vizualization&#34;&#34;&#34;
        self.train_val_distribution()
        self.class_wise_data_distribution()
        self.object_size_distribution()
        self.class_size_distribution()
        self.data_attributes_distribution()
        self.train_size_vs_map()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="source.visualize.Visualize.all"><code class="name flex">
<span>def <span class="ident">all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to make all plots for data vizualization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all(self):
    &#34;&#34;&#34;Function to make all plots for data vizualization&#34;&#34;&#34;
    self.train_val_distribution()
    self.class_wise_data_distribution()
    self.object_size_distribution()
    self.class_size_distribution()
    self.data_attributes_distribution()
    self.train_size_vs_map()</code></pre>
</details>
</dd>
<dt id="source.visualize.Visualize.class_size_distribution"><code class="name flex">
<span>def <span class="ident">class_size_distribution</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to plot object-size(area) vs no of sample distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def class_size_distribution(self):
    &#34;&#34;&#34;Function to plot object-size(area) vs no of sample distribution&#34;&#34;&#34;
    class_area_avg = {}
    tot_area = 0
    tot_sample = 0
    for c in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
        for i in range(len(self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1])):
            w = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1][i] // 100
            h = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][2][i] // 100
            tot_area += w * h
            tot_sample += 1
            if c in class_area_avg:
                class_area_avg[c][0] += w * h
                class_area_avg[c][1] += 1
            else:
                class_area_avg[c] = [(w * h), 1]
    color = cm.rainbow(np.linspace(0, 1, 10))
    fig, ax = plt.subplots()
    for i, c in enumerate(class_area_avg.keys()):
        circle = plt.Circle(
            ((i + 1) / 10, (class_area_avg[c][1] / tot_sample)),
            class_area_avg[c][0] / (tot_area * 2),
            color=color[i],
        )
        ax.annotate(
            c, xy=((i + 1) / 10, (class_area_avg[c][1] / tot_sample)), fontsize=12
        )
        ax.add_patch(circle)
    plt.ylabel(&#34;Number of samples&#34;)
    plt.title(&#34;Object-size vs #samples distribution&#34;)
    plt.savefig(&#34;plots/object_size_dist.png&#34;)</code></pre>
</details>
</dd>
<dt id="source.visualize.Visualize.class_wise_data_distribution"><code class="name flex">
<span>def <span class="ident">class_wise_data_distribution</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to plot class wise data distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def class_wise_data_distribution(self):
    &#34;&#34;&#34;Function to plot class wise data distribution&#34;&#34;&#34;
    data = self.train_val_data[&#34;train&#34;][&#34;class&#34;].keys()
    train_count = [x[0] for x in self.train_val_data[&#34;train&#34;][&#34;class&#34;].values()]
    X_axis = np.arange(len(data))
    plt.figure(figsize=(8, 6))
    plt.xticks(X_axis, data)
    plt.xticks(rotation=45, ha=&#34;right&#34;)
    plt.bar(data, train_count, 0.4, color=&#34;blue&#34;)
    plt.xlabel(&#34;class&#34;)
    plt.ylabel(&#34;Number of samples&#34;)
    plt.title(&#34;BDD dataset training class distribution&#34;)
    plt.savefig(&#34;plots/training_class_dist.png&#34;)
    data = self.train_val_data[&#34;val&#34;][&#34;class&#34;].keys()
    val_count = [x[0] for x in self.train_val_data[&#34;val&#34;][&#34;class&#34;].values()]
    X_axis = np.arange(len(data))
    plt.figure(figsize=(8, 6))
    plt.xticks(X_axis, data)
    plt.xticks(rotation=45, ha=&#34;right&#34;)
    plt.bar(data, val_count, 0.4, color=&#34;orange&#34;)
    plt.xlabel(&#34;class&#34;)
    plt.ylabel(&#34;Number of samples&#34;)
    plt.title(&#34;BDD dataset training class distribution&#34;)
    plt.savefig(&#34;plots/eval_class_dist.png&#34;)</code></pre>
</details>
</dd>
<dt id="source.visualize.Visualize.data_attributes_distribution"><code class="name flex">
<span>def <span class="ident">data_attributes_distribution</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to plot data occlusion and trucation distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_attributes_distribution(self):
    &#34;&#34;&#34;Function to plot data occlusion and trucation distribution&#34;&#34;&#34;
    attrib_counts = {&#34;occuluded&#34;: [0, 0], &#34;truncated&#34;: [0, 0]}
    for c in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
        for i in range(len(self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][3])):
            atr = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][3][i]
            attrib_counts[&#34;occuluded&#34;][1] += 1
            attrib_counts[&#34;truncated&#34;][1] += 1
            if atr[1]:
                attrib_counts[&#34;occuluded&#34;][0] += 1
            if atr[2]:
                attrib_counts[&#34;truncated&#34;][0] += 1

    fig, ax = plt.subplots()
    bottom = np.zeros(2)
    for cls, count in attrib_counts.items():
        p = ax.bar([&#34;occuluded&#34;, &#34;truncated&#34;], count, 0.5, label=cls, bottom=bottom)
        bottom += count
    plt.savefig(&#34;plots/object_attr_dist.png&#34;)</code></pre>
</details>
</dd>
<dt id="source.visualize.Visualize.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to load train and eval data classwise in memory from dataloader
to perform analysis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_data(self):
    &#34;&#34;&#34;Function to load train and eval data classwise in memory from dataloader
    to perform analysis.
    &#34;&#34;&#34;
    for im, lab, atr in self.trn_loader:
        b = self.trn_loader.scale_box(lab)
        for i, (c, b) in enumerate(lab):
            cat = self.trn_loader.data.config[&#34;names&#34;][c]
            if cat in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
                self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][0] += 1
                self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][1].append(b[2])
                self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][2].append(b[3])
                self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat][3].append(atr[i])
            else:
                self.train_val_data[&#34;train&#34;][&#34;class&#34;][cat] = [
                    1,
                    [b[2]],
                    [b[3]],
                    [atr[i]],
                ]

    for im, lab, atr in self.val_loader:
        b = self.trn_loader.scale_box(lab)
        for i, (c, b) in enumerate(lab):
            cat = self.trn_loader.data.config[&#34;names&#34;][c]
            if cat in self.train_val_data[&#34;val&#34;][&#34;class&#34;]:
                self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][0] += 1
                self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][1].append(b[2])
                self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][2].append(b[3])
                self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat][2].append(atr[i])
            else:
                self.train_val_data[&#34;val&#34;][&#34;class&#34;][cat] = [
                    1,
                    [b[2]],
                    [b[3]],
                    [atr[i]],
                ]</code></pre>
</details>
</dd>
<dt id="source.visualize.Visualize.object_size_distribution"><code class="name flex">
<span>def <span class="ident">object_size_distribution</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to plot width/heigh confusion metrix</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_size_distribution(self):
    &#34;&#34;&#34;Function to plot width/heigh confusion metrix&#34;&#34;&#34;
    array = [[0 for i in range(13)] for j in range(8)]
    tot = 0
    for c in self.train_val_data[&#34;train&#34;][&#34;class&#34;]:
        for i in range(len(self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1])):
            w = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][1][i] // 100
            h = self.train_val_data[&#34;train&#34;][&#34;class&#34;][c][2][i] // 100
            tot += 1
            array[h][w] = array[h][w] + (1 / tot)

    df_cm = pd.DataFrame(
        array,
        index=[i * 100 for i in range(8)],
        columns=[i * 100 for i in range(13)],
    )
    plt.figure(figsize=(10, 7))
    sn.heatmap(df_cm, annot=True, fmt=&#34;.1f&#34;)
    plt.savefig(&#34;plots/training_size_dist.png&#34;)</code></pre>
</details>
</dd>
<dt id="source.visualize.Visualize.show_yolo_annotations"><code class="name flex">
<span>def <span class="ident">show_yolo_annotations</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Function to overlay annotations on images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_yolo_annotations(self) -&gt; None:
    &#34;&#34;&#34;Function to overlay annotations on images&#34;&#34;&#34;
    os.makedirs(&#34;plots/images&#34;, exist_ok=True)
    colors = list(ImageColor.colormap.keys())[:10]
    font = ImageFont.truetype(&#34;plots/font/Arial.ttf&#34;, 24)
    for img, lab, atr in self.val_loader:
        draw = ImageDraw.Draw(img)
        lab = self.val_loader.scale_box(lab)
        for ann in lab:
            c, b = ann
            cls = self.val_loader.data.config[&#34;names&#34;][c]
            draw.rectangle(b, fill=None, outline=colors[c], width=3)
            draw.text((b[0] + 5, b[1]), cls[:3], font=font, fill=&#34;red&#34;)
        draw.text((5, 5), f&#34;* {atr[0][3]}&#34;, align=&#34;left&#34;, font=font, fill=&#34;red&#34;)
        draw.text((5, 25), f&#34;* {atr[0][4]}&#34;, align=&#34;left&#34;, font=font, fill=&#34;red&#34;)
        draw.text((5, 45), f&#34;* {atr[0][5]}&#34;, align=&#34;left&#34;, font=font, fill=&#34;red&#34;)
        img.save(&#34;plots/images/tmp.jpg&#34;)
        if input(&#34;&gt; &#34;) == &#34;s&#34;:
            img.save(f&#34;plots/images/{os.path.basename(self.val_loader.curr_fname)}&#34;)</code></pre>
</details>
</dd>
<dt id="source.visualize.Visualize.train_size_vs_map"><code class="name flex">
<span>def <span class="ident">train_size_vs_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to plot train/val size vs map</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def train_size_vs_map(self):
    &#34;&#34;&#34;Function to plot train/val size vs map&#34;&#34;&#34;
    data = self.train_val_data[&#34;train&#34;][&#34;class&#34;].keys()
    train_count = [x[0] for x in self.train_val_data[&#34;train&#34;][&#34;class&#34;].values()]
    tot = sum(train_count)
    for i in range(len(train_count)):
        train_count[i] /= tot
    val_count = [0.57, 0.62, 0.77, 0.59, 0.43, 0.43, 0.62, 0.60, 0.42, 0.0]
    X_axis = np.arange(len(data))
    plt.figure(figsize=(8, 6))
    plt.xticks(X_axis, data)
    plt.xticks(rotation=45, ha=&#34;right&#34;)
    plt.bar(X_axis - 0.2, train_count, 0.4, label=&#34;samples&#34;)
    plt.bar(X_axis + 0.2, val_count, 0.4, label=&#34;mAP&#34;)
    plt.legend()
    plt.xlabel(&#34;class&#34;)
    plt.ylabel(&#34;Number of samples&#34;)
    plt.title(&#34;BDD dataset samples vs map distribution&#34;)
    plt.savefig(&#34;plots/sample_map_dist.png&#34;)</code></pre>
</details>
</dd>
<dt id="source.visualize.Visualize.train_val_distribution"><code class="name flex">
<span>def <span class="ident">train_val_distribution</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to plot tain-val data distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def train_val_distribution(self):
    &#34;&#34;&#34;Function to plot tain-val data distribution&#34;&#34;&#34;
    data = [&#34;train&#34;, &#34;val&#34;]
    samples = [len(self.trn_loader), len(self.val_loader)]

    plt.figure(figsize=(8, 6))
    plt.bar(data, samples, color=&#34;blue&#34;, width=0.4)
    plt.ylabel(&#34;Number of samples&#34;)
    plt.title(&#34;BDD dataset training data distribution&#34;)
    plt.savefig(&#34;plots/train_val_dist.png&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="source" href="index.html">source</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="source.visualize.Visualize" href="#source.visualize.Visualize">Visualize</a></code></h4>
<ul class="">
<li><code><a title="source.visualize.Visualize.all" href="#source.visualize.Visualize.all">all</a></code></li>
<li><code><a title="source.visualize.Visualize.class_size_distribution" href="#source.visualize.Visualize.class_size_distribution">class_size_distribution</a></code></li>
<li><code><a title="source.visualize.Visualize.class_wise_data_distribution" href="#source.visualize.Visualize.class_wise_data_distribution">class_wise_data_distribution</a></code></li>
<li><code><a title="source.visualize.Visualize.data_attributes_distribution" href="#source.visualize.Visualize.data_attributes_distribution">data_attributes_distribution</a></code></li>
<li><code><a title="source.visualize.Visualize.load_data" href="#source.visualize.Visualize.load_data">load_data</a></code></li>
<li><code><a title="source.visualize.Visualize.object_size_distribution" href="#source.visualize.Visualize.object_size_distribution">object_size_distribution</a></code></li>
<li><code><a title="source.visualize.Visualize.show_yolo_annotations" href="#source.visualize.Visualize.show_yolo_annotations">show_yolo_annotations</a></code></li>
<li><code><a title="source.visualize.Visualize.train_size_vs_map" href="#source.visualize.Visualize.train_size_vs_map">train_size_vs_map</a></code></li>
<li><code><a title="source.visualize.Visualize.train_val_distribution" href="#source.visualize.Visualize.train_val_distribution">train_val_distribution</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>